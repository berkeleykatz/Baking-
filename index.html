<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>My Recipe Collection</title>

  <!-- Tailwind utilities -->
  <script src="https://cdn.tailwindcss.com" defer></script>
  <!-- Tesseract.js (newer, faster) -->
  <script src="https://unpkg.com/tesseract.js@4.0.3/dist/tesseract.min.js"></script>

  <style>
    :root{--bg1:#ffecd2;--bg2:#fcb69f;--text:#5d4037;--primary:#ff6f61;--secondary:#4caf50;--surface:#fff;--chip:#ffe0b2;--chipText:#e65100}
    html,body{height:100%}*{box-sizing:border-box}
    body{margin:0;font-family:Georgia,serif;color:var(--text);background:linear-gradient(135deg,var(--bg1) 0%,var(--bg2) 100%)}
    .container{max-width:1200px;margin:0 auto;padding:2rem}
    .header{text-align:center;margin-bottom:2rem}
    .header h1{font-size:2.5rem;margin:0 0 .5rem;text-shadow:2px 2px 4px rgba(0,0,0,.1)}
    .btn{display:inline-flex;align-items:center;justify-content:center;gap:.4rem;border:none;border-radius:999px;padding:.75rem 1.25rem;font-weight:700;cursor:pointer;transition:.2s}
    .btn-primary{background:var(--primary);color:#fff}.btn-primary:hover{filter:brightness(.95);transform:translateY(-1px)}
    .btn-secondary{background:var(--secondary);color:#fff}.btn-ghost{background:#fff;border:2px solid var(--text);color:var(--text);border-radius:20px;padding:.5rem 1rem}
    .btn-ghost.active,.btn-ghost:hover{background:var(--text);color:#fff}
    .grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(300px,1fr));gap:1.25rem}
    .card{background:var(--surface);border-radius:16px;padding:1.25rem;box-shadow:0 4px 8px rgba(0,0,0,.1)}
    .chip{background:var(--chip);color:var(--chipText);padding:.25rem .6rem;border-radius:14px;font-weight:700;font-size:.8rem}
    .rating{display:flex;gap:.25rem;margin:.5rem 0 1rem}.star{font-size:1.4rem;cursor:pointer}.star.filled{color:#ffd700}.star.empty{color:#ddd}
    .modal{position:fixed;inset:0;background:rgba(0,0,0,.5);display:none;align-items:center;justify-content:center;padding:2rem;z-index:50}
    .modal.active{display:flex}.modal-content{background:#fff;border-radius:16px;padding:1.5rem;max-width:900px;width:100%;max-height:90%;overflow:auto}
    .form{display:grid;gap:1rem}.form label{font-weight:700;margin-bottom:.35rem;display:block}
    .input,.select,.textarea{width:100%;padding:.75rem;border:2px solid #ddd;border-radius:8px;font:inherit}
    .textarea{min-height:110px;resize:vertical}
    .limit{background:#fff3cd;border:2px solid #ffc107;color:#7a5d00;padding:1rem;border-radius:10px;text-align:center;font-weight:700;margin:1rem 0}
    .thumb{width:120px;height:90px;border-radius:8px;object-fit:cover;border:1px solid #e5e7eb}
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>My Recipe Collection</h1>
      <p>Organize and rate your favorite baking recipes</p>
    </div>

    <div id="limit" class="limit" style="display:none">Maximum limit of 999 recipes reached.</div>

    <div class="flex flex-wrap items-center gap-3 mb-6">
      <button id="addBtn" class="btn btn-primary">‚ûï Add New Recipe</button>
      <div class="flex flex-wrap gap-2">
        <button class="btn-ghost active" data-filter="all">All</button>
        <button class="btn-ghost" data-filter="Cakes">üéÇ Cakes</button>
        <button class="btn-ghost" data-filter="Cookies">üç™ Cookies</button>
        <button class="btn-ghost" data-filter="Pies">ü•ß Pies</button>
        <button class="btn-ghost" data-filter="Bread">üçû Bread</button>
        <button class="btn-ghost" data-filter="Other">Other</button>
      </div>
    </div>

    <div id="grid" class="grid"></div>
  </div>

  <!-- Modal -->
  <div id="modal" class="modal" aria-hidden="true">
    <div class="modal-content">
      <div class="flex items-center justify-between mb-4">
        <h2 id="modalTitle" class="text-2xl m-0">Add New Recipe</h2>
        <button id="closeModal" class="btn-ghost">‚úï</button>
      </div>

      <form id="form" class="form">
        <div>
          <label for="name">Recipe Name</label>
          <input id="name" class="input" type="text" required placeholder="e.g., Chocolate Chip Cookies">
        </div>

        <div>
          <label for="cat">Category</label>
          <select id="cat" class="select" required>
            <option value="">Select a category</option>
            <option value="Cakes">Cakes</option>
            <option value="Cookies">Cookies</option>
            <option value="Pies">Pies</option>
            <option value="Bread">Bread</option>
            <option value="Other">Other</option>
          </select>
        </div>

        <div>
          <label for="ingredients">Ingredients</label>
          <textarea id="ingredients" class="textarea" required placeholder="One per line"></textarea>
        </div>

        <div>
          <label for="instructions">Instructions</label>
          <textarea id="instructions" class="textarea" required placeholder="Step-by-step"></textarea>
        </div>

        <!-- MULTI-PHOTO OCR -->
        <div>
          <label for="photos">Upload recipe photos (you can choose multiple)</label>
          <input id="photos" type="file" accept="image/*" class="input" multiple>
          <div id="photosPreview" class="mt-2 flex flex-wrap gap-2"></div>
          <div class="mt-2 flex items-center gap-2">
            <button id="scanBtn" type="button" class="btn btn-secondary">Scan Photos</button>
            <span id="scanProgress" class="text-sm"></span>
          </div>
          <div class="text-xs text-gray-600 mt-1">Tip: crop each photo tightly around the recipe text.</div>
        </div>

        <!-- VIDEO OCR (optional) -->
        <div>
          <label for="video">Upload video (sample frames to OCR)</label>
          <input id="video" type="file" accept="video/*" class="input">
          <div class="mt-2 flex items-center gap-2">
            <button id="analyzeBtn" type="button" class="btn btn-secondary">Analyze Video</button>
            <span id="analyzeProgress" class="text-sm"></span>
          </div>
        </div>

        <!-- Finished photo shown on card -->
        <div>
          <label for="finished">Upload finished-photo (shown above recipe)</label>
          <input id="finished" type="file" accept="image/*" class="input">
          <img id="finishedPreview" class="thumb mt-2" style="display:none" alt="Finished photo preview">
        </div>

        <div class="grid grid-cols-2 gap-3 mt-2">
          <button id="cancelBtn" type="button" class="btn btn-ghost">Cancel</button>
          <button id="saveBtn" type="submit" class="btn btn-primary">Save Recipe</button>
        </div>
      </form>
    </div>
  </div>

  <!-- Hidden for OCR work -->
  <video id="hiddenVideo" style="display:none"></video>
  <canvas id="canvas" style="display:none"></canvas>

  <script>
/* ========= storage ========= */
const KEY='recipes_v1';
const load=()=>{ try{return JSON.parse(localStorage.getItem(KEY))||[]}catch{return[]} };
const save=a=>localStorage.setItem(KEY,JSON.stringify(a));

/* ========= OCR tuning ========= */
const OCR_WHITELIST =
  "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789" +
  " .,:;!?'-‚Äì‚Äî()/+%¬∞¬Ω¬º¬æ&\n";

/* ========= state & elements ========= */
let recipes=load(), filter='all', editingId=null;
const $=s=>document.querySelector(s);
const grid=$('#grid'), limit=$('#limit'), modal=$('#modal'), form=$('#form'), modalTitle=$('#modalTitle');
const nameEl=$('#name'), catEl=$('#cat'), ingEl=$('#ingredients'), instEl=$('#instructions');
const finishedEl=$('#finished'), finishedPreview=$('#finishedPreview');
const photosEl=$('#photos'), photosPreview=$('#photosPreview'), scanBtn=$('#scanBtn'), scanProgress=$('#scanProgress');
const videoEl=$('#video'), analyzeBtn=$('#analyzeBtn'), analyzeProgress=$('#analyzeProgress');

/* ========= events ========= */
$('#addBtn').addEventListener('click',openAdd);
$('#closeModal').addEventListener('click',closeModal);
$('#cancelBtn').addEventListener('click',closeModal);
document.querySelectorAll('[data-filter]').forEach(b=>{
  b.addEventListener('click',e=>{
    document.querySelectorAll('[data-filter]').forEach(x=>x.classList.remove('active'));
    e.currentTarget.classList.add('active'); filter=e.currentTarget.dataset.filter; render();
  });
});
finishedEl.addEventListener('change',()=>previewImage(finishedEl,finishedPreview));
photosEl.addEventListener('change',()=>{
  photosPreview.innerHTML=''; const files=[...(photosEl.files||[])];
  files.forEach(file=>{
    const img=document.createElement('img'); img.className='thumb'; img.alt='Recipe photo preview';
    const fr=new FileReader(); fr.onload=e=>img.src=e.target.result; fr.readAsDataURL(file);
    photosPreview.appendChild(img);
  });
});

scanBtn.addEventListener('click',async()=>{
  const files=[...(photosEl.files||[])];
  if(!files.length) return alert('Choose one or more recipe photos first.');

  try{
    const results=[];
    for(let i=0;i<files.length;i++){
      const f=files[i];
      scanProgress.textContent=`Photo ${i+1}/${files.length}: preprocessing...`;
      const pre=await preprocessImage(f);

      scanProgress.textContent=`Photo ${i+1}: scanning best angle/mode...`;
      const best=await runOCRMulti(pre);   // deskew + PSM6/3 + whitelist
      results.push(best);
    }

    const merged=mergeOCRResults(results);
    const parsed=merged.parsedFromWords || parsePlainText(merged.textAll);

    if(parsed.name) nameEl.value=parsed.name;
    if(parsed.ingredients) ingEl.value=parsed.ingredients;
    if(parsed.instructions) instEl.value=parsed.instructions;

    const conf=Math.round(avg(results.map(r=>r.avgConf)));
    scanProgress.textContent=`Done (avg confidence ~${conf}).`;
  }catch(err){
    console.error(err); alert('Scanning failed. Try clearer photos and crop to the text.');
    scanProgress.textContent='Failed';
  }finally{ setTimeout(()=>scanProgress.textContent='',1500); }
});

analyzeBtn.addEventListener('click',async()=>{
  const f=videoEl.files&&videoEl.files[0]; if(!f) return alert('Choose a video first.');
  try{
    analyzeProgress.textContent='Preparing video...';
    const text=await ocrVideo(f,(s)=>analyzeProgress.textContent=s);
    const parsed=parsePlainText(text);
    if(parsed.name) nameEl.value=parsed.name;
    if(parsed.ingredients) ingEl.value=parsed.ingredients;
    if(parsed.instructions) instEl.value=parsed.instructions;
    analyzeProgress.textContent='Done.';
  }catch(e){ console.error(e); analyzeProgress.textContent='Failed'; }
  finally{ setTimeout(()=>analyzeProgress.textContent='',1200); }
});

form.addEventListener('submit',async(e)=>{
  e.preventDefault();
  $('#saveBtn').disabled=true; $('#saveBtn').textContent='Saving...';

  const rec={
    name:nameEl.value.trim(),
    category:catEl.value,
    ingredients:ingEl.value.trim(),
    instructions:instEl.value.trim(),
    rating:0,
    createdAt:new Date().toISOString()
  };

  // save finished photo
  if (finishedEl.files && finishedEl.files[0]) {
    rec.finishedPhoto = await fileToDataURL(finishedEl.files[0]).catch(()=>null);
  }
  // save source photos (optional)
  if (photosEl.files && photosEl.files.length) {
    rec.sourcePhotos = [];
    for (const f of photosEl.files) {
      try { rec.sourcePhotos.push(await fileToDataURL(f)); } catch {}
    }
  }

  if (editingId) {
    const i=recipes.findIndex(r=>r.__id===editingId);
    if(i>=0) recipes[i]={...recipes[i],...rec};
    editingId=null;
  } else {
    if(recipes.length>=999){ alert('Maximum 999 recipes reached.'); $('#saveBtn').disabled=false; $('#saveBtn').textContent='Save Recipe'; return; }
    rec.__id=crypto.randomUUID?crypto.randomUUID():String(Date.now());
    recipes.push(rec);
  }
  save(recipes); closeModal(); render();
  $('#saveBtn').disabled=false; $('#saveBtn').textContent='Save Recipe';
});

/* ========= UI ========= */
function openAdd(){ editingId=null; modalTitle.textContent='Add New Recipe'; form.reset(); finishedPreview.style.display='none'; photosPreview.innerHTML=''; modal.classList.add('active'); }
function openEdit(r){
  editingId=r.__id; modalTitle.textContent='Edit Recipe';
  nameEl.value=r.name||''; catEl.value=r.category||''; ingEl.value=r.ingredients||''; instEl.value=r.instructions||'';
  if(r.finishedPhoto){ finishedPreview.src=r.finishedPhoto; finishedPreview.style.display='block'; } else finishedPreview.style.display='none';
  photosPreview.innerHTML=''; modal.classList.add('active');
}
function closeModal(){ modal.classList.remove('active'); }
function render(){
  limit.style.display=recipes.length>=999?'block':'none';
  const list=(filter==='all')?recipes:recipes.filter(r=>r.category===filter);
  if(!list.length){
    grid.innerHTML=`<div class="card text-center"><h2 class="text-xl m-0">No recipes yet!</h2><p>Click ‚ÄúAdd New Recipe‚Äù to get started üç∞</p></div>`;
    return;
  }
  grid.innerHTML=''; list.forEach(r=>grid.appendChild(card(r)));
}
function card(r){
  const el=document.createElement('div'); el.className='card';
  const photo=r.finishedPhoto?`<div class="text-center mb-3"><img src="${r.finishedPhoto}" alt="" style="max-width:100%;border-radius:10px;object-fit:cover"></div>`:'';
  el.innerHTML=`
    ${photo}
    <div class="flex items-start justify-between mb-2">
      <h3 class="m-0 text-lg" style="color:var(--text)">${esc(r.name)}</h3>
      <span class="chip">${esc(r.category||'')}</span>
    </div>
    <div class="rating" data-id="${r.__id}">
      ${[1,2,3,4,5].map(n=>`<span class="star ${n<=(r.rating||0)?'filled':'empty'}" data-rating="${n}">‚òÖ</span>`).join('')}
    </div>
    <div class="mb-2"><h4 class="m-0 text-sm">Ingredients</h4><p class="m-0 whitespace-pre-line">${esc(r.ingredients||'')}</p></div>
    <div><h4 class="m-0 text-sm">Instructions</h4><p class="m-0 whitespace-pre-line">${esc(r.instructions||'')}</p></div>
    <div class="grid grid-cols-2 gap-2 mt-3">
      <button class="btn btn-secondary edit">Edit</button>
      <button class="btn btn-primary delete" style="background:#f44336">Delete</button>
    </div>`;
  el.querySelector('.rating').addEventListener('click',e=>{
    if(!e.target.classList.contains('star')) return;
    const rate=+e.target.dataset.rating; const i=recipes.findIndex(x=>x.__id===r.__id);
    if(i>=0){ recipes[i].rating=rate; save(recipes); render(); }
  });
  el.querySelector('.edit').addEventListener('click',()=>openEdit(r));
  el.querySelector('.delete').addEventListener('click',()=>{ if(!confirm(`Delete "${r.name}"?`))return; recipes=recipes.filter(x=>x.__id!==r.__id); save(recipes); render(); });
  return el;
}

/* ========= OCR: preprocessing + deskew + merge + parsing ========= */
async function preprocessImage(file){
  const img=await loadImageFromFile(file);
  const canvas=document.getElementById('canvas'), ctx=canvas.getContext('2d');
  const targetW=Math.max(1400,img.width), scale=targetW/img.width;
  const w=Math.round(img.width*scale), h=Math.round(img.height*scale);
  canvas.width=w; canvas.height=h; ctx.drawImage(img,0,0,w,h);

  // grayscale
  let data=ctx.getImageData(0,0,w,h), d=data.data;
  for(let i=0;i<d.length;i+=4){ const r=d[i],g=d[i+1],b=d[i+2]; const y=0.299*r+0.587*g+0.114*b; d[i]=d[i+1]=d[i+2]=y; }
  ctx.putImageData(data,0,0);

  // tile-based adaptive threshold
  data=ctx.getImageData(0,0,w,h); d=data.data;
  const tile=32;
  for(let ty=0;ty<h;ty+=tile){
    for(let tx=0;tx<w;tx+=tile){
      let sum=0,cnt=0;
      for(let y=ty;y<Math.min(ty+tile,h);y+=4){
        for(let x=tx;x<Math.min(tx+tile,w);x+=4){ sum+=d[(y*w+x)*4]; cnt++; }
      }
      const thr=(sum/cnt)-10;
      for(let y=ty;y<Math.min(ty+tile,h);y++){
        for(let x=tx;x<Math.min(tx+tile,w);x++){
          const idx=(y*w+x)*4; const v=d[idx]<thr?0:255; d[idx]=d[idx+1]=d[idx+2]=v;
        }
      }
    }
  }
  ctx.putImageData(data,0,0);
  return canvas.toDataURL('image/png');
}

async function rotateDataURL(dataUrl, degrees) {
  return new Promise((resolve) => {
    const img = new Image();
    img.onload = () => {
      const rad = degrees * Math.PI / 180;
      const sin = Math.abs(Math.sin(rad)), cos = Math.abs(Math.cos(rad));
      const w = img.width, h = img.height;
      const cw = Math.round(w * cos + h * sin);
      const ch = Math.round(w * sin + h * cos);

      const canvas = document.createElement('canvas');
      canvas.width = cw; canvas.height = ch;
      const ctx = canvas.getContext('2d');
      ctx.translate(cw / 2, ch / 2);
      ctx.rotate(rad);
      ctx.drawImage(img, -w / 2, -h / 2);
      resolve(canvas.toDataURL('image/png'));
    };
    img.src = dataUrl;
  });
}

async function runOCRSingle(dataUrl, { psm = 6 } = {}) {
  const res = await Tesseract.recognize(
    dataUrl, 'eng',
    {
      tessedit_pageseg_mode: psm,
      preserve_interword_spaces: '1',
      user_defined_dpi: '300',
      tessedit_char_whitelist: OCR_WHITELIST
    }
  );
  const words = res.data.words || [];
  const avgConf = words.length
      ? words.reduce((a, w) => a + (w.conf || 0), 0) / words.length
      : (res.data.conf || 0);
  return { words, avgConf, text: res.data.text || '' };
}

// Try angles and both PSM modes; choose the best by avg confidence
async function runOCRMulti(dataUrl) {
  const ANGLES = [-3, -2, -1, 0, 1, 2, 3];
  let best = { avgConf: -1 };

  for (const deg of ANGLES) {
    const rotated = (deg === 0) ? dataUrl : await rotateDataURL(dataUrl, deg);

    const a = await runOCRSingle(rotated, { psm: 6 });
    if (a.avgConf > best.avgConf) best = { ...a, _deg: deg, _psm: 6 };

    const b = await runOCRSingle(rotated, { psm: 3 });
    if (b.avgConf > best.avgConf) best = { ...b, _deg: deg, _psm: 3 };
  }
  return best;
}

function mergeOCRResults(results){
  const textAll=results.map(r=>r.text||'').join('\n');
  const mergedWords=[];
  results.forEach(r=>{ (r.words||[]).forEach(w=>{ if((w.conf||0)>=60) mergedWords.push(w); }); });
  let parsedFromWords=null;
  if(mergedWords.length){ parsedFromWords=parseFromWords({words:mergedWords,avgConf:avg(results.map(r=>r.avgConf))}); }
  return { textAll, parsedFromWords };
}

function parseFromWords(result){
  const words=(result.words||[]).filter(w=>(w.conf||0)>=60);
  if(!words.length) return {name:'',ingredients:'',instructions:''};

  // group into lines by y-center band
  const linesMap=new Map();
  for(const w of words){ const cy=(w.bbox.y0+w.bbox.y1)/2, key=Math.round(cy/18); (linesMap.get(key)||linesMap.set(key,[]).get(key)).push(w); }
  const lines=[...linesMap.values()].map(ws=>{
    ws.sort((a,b)=>a.bbox.x0-b.bbox.x0);
    const text=ws.map(x=>x.text).join(' ');
    const xCenter=ws.reduce((s,x)=>s+(x.bbox.x0+x.bbox.x1)/2,0)/ws.length;
    return {text,xCenter};
  }).sort((a,b)=>a.xCenter-b.xCenter);

  // split columns with median x
  const xs=lines.map(l=>l.xCenter).sort((a,b)=>a-b);
  const med=xs[Math.floor(xs.length/2)];
  const left=lines.filter(l=>l.xCenter<=med).map(l=>l.text);
  const right=lines.filter(l=>l.xCenter> med).map(l=>l.text);

  const score = arr => arr.filter(s=>/\b(\d+|\d+\/\d+|¬Ω|¬º|¬æ)\b/.test(s)||/\b(cup|tbsp|tsp|g|gram|ml|oz|teaspoon|tablespoon|pinch|kg)\b/i.test(s)).length;
  const leftScore=score(left), rightScore=score(right);
  const ingLines=leftScore>=rightScore?left:right;
  const other=leftScore>=rightScore?right:left;

  const name=(other.find(s=>s && !/\b(cup|tbsp|tsp|g|gram|ml|oz)\b/i.test(s))||'').replace(/^\W+|\W+$/g,'');

  const ingredients=cleanList(ingLines);
  let instructions=cleanSteps(other);
  if(!instructions.trim()) instructions=cleanSteps(lines.map(l=>l.text));

  return { name, ingredients, instructions };
}

function parsePlainText(text){
  const lines=(text||'').split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
  if(!lines.length) return {name:'',ingredients:'',instructions:''};
  let name=lines[0], idxIng=lines.findIndex(l=>/ingredient[s]?\b/i.test(l)), idxIns=lines.findIndex(l=>/instruction[s]?|method|directions/i.test(l));
  let ing='',ins='';
  if(idxIng>=0&&idxIns>=0){ ing=lines.slice(idxIng+1,idxIns).join('\n'); ins=lines.slice(idxIns+1).join('\n'); }
  else{ const stepStart=lines.findIndex(l=>/^\d+[\).]\s+/.test(l)); if(stepStart>=0){ ing=lines.slice(1,stepStart).join('\n'); ins=lines.slice(stepStart).join('\n'); } else { const split=Math.max(1,Math.floor(lines.length/3)); ing=lines.slice(1,split+1).join('\n'); ins=lines.slice(split+1).join('\n'); } }
  if(!/\b(cup|tbsp|tsp|g|gram|ml|oz|teaspoon|tablespoon|pinch|kg)\b/i.test(ing)){ const il=lines.filter(l=>/\b(\d+|\d+\/\d+|¬Ω|¬º|¬æ)\b/.test(l)); if(il.length) ing=il.join('\n'); }
  return { name, ingredients: ing, instructions: ins };
}

/* ========= helpers ========= */
function cleanList(arr){ return arr.map(s=>s.replace(/^[‚Ä¢¬∑‚ñ™‚óè\-‚Äì‚Äî]\s*/,'').trim()).filter(s=>s.length>1).join('\n'); }
function cleanSteps(arr){ const steps=arr.filter(s=>/^\d+[\).]\s+/.test(s)||/\b(mix|stir|bake|heat|add|whisk|pour|preheat|combine|fold|cool|serve)\b/i.test(s)); return steps.map(s=>s.replace(/^\d+[\).]\s*/,'')).join('\n'); }
function esc(s){ return String(s||'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#039;'); }
function previewImage(input,img){ const f=input.files&&input.files[0]; if(!f){img.style.display='none';return} const fr=new FileReader(); fr.onload=e=>{img.src=e.target.result;img.style.display='block'}; fr.readAsDataURL(f); }
function fileToDataURL(file){ return new Promise((res,rej)=>{ const fr=new FileReader(); fr.onload=e=>res(e.target.result); fr.onerror=rej; fr.readAsDataURL(file); }); }
function loadImageFromFile(file){ return new Promise((res,rej)=>{ const img=new Image(); img.onload=()=>res(img); img.onerror=rej; img.src=URL.createObjectURL(file); }); }
function avg(a){ return a.length ? a.reduce((x,y)=>x+y,0)/a.length : 0; }

/* ========= video OCR ========= */
async function ocrVideo(file,setStatus){
  const MAX=3, url=URL.createObjectURL(file), video=document.getElementById('hiddenVideo'), canvas=document.getElementById('canvas'), ctx=canvas.getContext('2d');
  return new Promise((resolve,reject)=>{
    const cleanup=()=>{ try{URL.revokeObjectURL(url)}catch{} video.pause(); video.removeAttribute('src'); };
    video.onloadedmetadata=async()=>{
      const dur=video.duration||0; if(!dur||!isFinite(dur)){cleanup(); return reject(new Error('Bad video')); }
      const frames=Math.min(MAX,Math.ceil(dur)); const times=Array.from({length:frames},(_,i)=>(i+1)/(frames+1)*dur); let text='';
      for(let i=0;i<times.length;i++){
        const t=times[i]; setStatus&&setStatus(`Frame ${i+1}/${frames}‚Ä¶`);
        await new Promise(r=>{ const onSeek=()=>{video.removeEventListener('seeked',onSeek); r();}; video.addEventListener('seeked',onSeek); video.currentTime=Math.min(Math.max(0,t),Math.max(0,dur-.1)); setTimeout(()=>{video.removeEventListener('seeked',onSeek); r();},3000); });
        canvas.width=Math.min(video.videoWidth,1280); canvas.height=Math.min(video.videoHeight,720); ctx.drawImage(video,0,0,canvas.width,canvas.height);
        const blob=await new Promise(r=>canvas.toBlob(r,'image/png')); const u2=URL.createObjectURL(blob);
        const res=await Tesseract.recognize(u2,'eng',{tessedit_pageseg_mode:3}); text+='\n'+(res.data.text||''); URL.revokeObjectURL(u2);
      }
      cleanup(); resolve(text);
    };
    video.onerror=()=>{cleanup(); reject(new Error('Video load error')); };
    video.src=url; video.preload='metadata'; video.muted=true;
  });
}

/* ========= boot ========= */
render();
  </script>
</body>
</html>
